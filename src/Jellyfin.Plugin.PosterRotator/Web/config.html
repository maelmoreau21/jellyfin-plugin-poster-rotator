<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <title>Poster Rotator</title>
  <style>
    .fieldDescription {
      font-size: 0.85em;
      color: #999;
      margin-top: 4px;
    }

    .checkboxContainer-withDescription {
      margin-top: 16px;
    }

    .inputContainer {
      margin-top: 12px;
    }
  </style>
</head>

<body>
  <div id="PosterRotatorConfigPage" data-role="page" class="page type-interior pluginConfigurationPage"
    data-require="emby-input,emby-button,emby-checkbox">

    <div data-role="content">
      <div class="content-primary">
        <form id="PosterRotatorConfigForm">

          <!-- SECTION: Biblioth√®ques -->
          <h2>Biblioth√®ques √† affecter</h2>

          <!-- Container pour les r√®gles de librairie (rempli par le JS) -->
          <div id="LibraryRulesContainer" style="margin-top:12px; margin-bottom:14px;"></div>

          <!-- SECTION: Param√®tres de rotation -->
          <h2>Param√®tres de rotation</h2>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="PoolSize">Taille du pool (affiches par film)</label>
            <input id="PoolSize" type="number" min="1" max="20" is="emby-input" value="5" />
            <div class="fieldDescription">Nombre d'affiches √† conserver par film</div>
          </div>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="MinHoursBetweenSwitches">Heures minimum entre les
              changements</label>
            <input id="MinHoursBetweenSwitches" type="number" min="1" is="emby-input" value="24" />
            <div class="fieldDescription">Dur√©e minimale avant de changer l'affiche (en heures)</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="SequentialRotation" type="checkbox" is="emby-checkbox" />
              <span>Rotation s√©quentielle</span>
            </label>
            <div class="fieldDescription">Si d√©coch√©: rotation al√©atoire</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="LockImagesAfterFill" type="checkbox" is="emby-checkbox" />
              <span>Verrouiller apr√®s remplissage du pool</span>
            </label>
            <div class="fieldDescription">Emp√™che les mises √† jour de m√©tadonn√©es de modifier le pool</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="EnableSeasonPosters" type="checkbox" is="emby-checkbox" />
              <span>Inclure les saisons</span>
            </label>
            <div class="fieldDescription">Ajoute les affiches des saisons √† la rotation (d√©sactiv√© par d√©faut)</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="EnableEpisodePosters" type="checkbox" is="emby-checkbox" />
              <span>Inclure les √©pisodes</span>
            </label>
            <div class="fieldDescription">Ajoute les miniatures des √©pisodes √† la rotation (d√©sactiv√© par d√©faut)</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription" style="margin-bottom:14px;">
            <label class="emby-checkbox-label">
              <input id="TriggerLibraryScanAfterRotation" type="checkbox" is="emby-checkbox" />
              <span>D√©clencher un scan de la biblioth√®que apr√®s rotation</span>
            </label>
            <div class="fieldDescription">Optionnel et co√ªteux : force un scan pour que Jellyfin r√©indexe les images
              (activ√© par d√©faut)</div>
          </div>

          <!-- SECTION: Param√®tres avanc√©s -->
          <h2>Param√®tres avanc√©s</h2>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="ExtraPosterPatterns">Motifs suppl√©mentaires (s√©par√©s par
              virgule)</label>
            <input id="ExtraPosterPatterns" type="text" is="emby-input" placeholder="folder.jpg, alt-*.png" />
          </div>

          <div style="display: flex; gap: 16px;">
            <div class="inputContainer" style="flex: 1;">
              <label class="inputLabel inputLabelUnfocused" for="MinImageWidth">Largeur minimale (px)</label>
              <input id="MinImageWidth" type="number" min="0" max="4000" is="emby-input" value="500" />
              <div class="fieldDescription">Images plus √©troites seront rejet√©es (0 = pas de filtre)</div>
            </div>
            <div class="inputContainer" style="flex: 1;">
              <label class="inputLabel inputLabelUnfocused" for="MinImageHeight">Hauteur minimale (px)</label>
              <input id="MinImageHeight" type="number" min="0" max="4000" is="emby-input" value="750" />
              <div class="fieldDescription">Images plus courtes seront rejet√©es (0 = pas de filtre)</div>
            </div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="EnableDuplicateDetection" type="checkbox" is="emby-checkbox" />
              <span>D√©tection des doublons visuels</span>
            </label>
            <div class="fieldDescription">Utilise un hash perceptuel pour rejeter les images quasi-identiques lors du
              t√©l√©chargement</div>
          </div>

          <!-- SECTION: Gestion des pools -->
          <h2>Gestion des pools</h2>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="AutoCleanupOrphanedPools" type="checkbox" is="emby-checkbox" />
              <span>Nettoyage automatique des pools orphelins</span>
            </label>
            <div class="fieldDescription">Supprime automatiquement les pools dont le m√©dia a √©t√© supprim√©</div>
          </div>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="CleanupIntervalDays">Intervalle de nettoyage
              (jours)</label>
            <input id="CleanupIntervalDays" type="number" min="1" max="30" is="emby-input" value="7" />
            <div class="fieldDescription">Nombre de jours entre chaque nettoyage automatique</div>
          </div>

          <div style="margin-top: 16px;">
            <button id="PurgeAllPoolsBtn" type="button" class="raised button-cancel emby-button"
              style="display: inline-block; padding: 12px 24px;">
              üóë Supprimer tous les pools
            </button>
            <div class="fieldDescription">Supprime tous les dossiers .poster_pool de toutes les biblioth√®ques. Cette
              action est irr√©versible.</div>
            <div id="PurgeResult" style="display:none; margin-top: 8px; color: #4caf50; font-weight: bold;"></div>
          </div>

          <!-- SECTION: Pr√©f√©rences de langue -->
          <h2>Pr√©f√©rences de langue des affiches</h2>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="EnableLanguageFilter" type="checkbox" is="emby-checkbox" />
              <span>Activer le filtrage par langue</span>
            </label>
            <div class="fieldDescription">Permet de contr√¥ler le nombre d'affiches par langue dans le pool</div>
          </div>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="PreferredLanguage">Langue pr√©f√©r√©e (code ISO)</label>
            <input id="PreferredLanguage" type="text" is="emby-input" value="fr" placeholder="fr, en, de, es..." />
            <div class="fieldDescription">Code de langue pour les affiches prioritaires (ex: fr pour fran√ßais)</div>
          </div>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="MaxPreferredLanguageImages">Nombre max d'images dans la
              langue preferee</label>
            <input id="MaxPreferredLanguageImages" type="number" min="0" max="10" is="emby-input" value="2" />
            <div class="fieldDescription">Ex: 2 = maximum 2 affiches francaises, le reste sera en VO</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="UseOriginalLanguageAsFallback" type="checkbox" is="emby-checkbox" checked />
              <span>Utiliser la langue originale du media (vraie VO)</span>
            </label>
            <div class="fieldDescription">Detecte automatiquement la langue originale (ex: japonais pour les animes,
              coreen pour les K-dramas). Si desactive, utilise la langue de fallback ci-dessous.</div>
          </div>

          <div class="inputContainer">
            <label class="inputLabel inputLabelUnfocused" for="FallbackLanguage">Langue de fallback (si auto-detection
              echoue)</label>
            <input id="FallbackLanguage" type="text" is="emby-input" value="en"
              placeholder="en, de, es, ja, ko... (vide = toutes)" />
            <div class="fieldDescription">Utilise seulement si "Utiliser la langue originale" est desactive ou si la
              detection echoue.</div>
          </div>

          <div class="checkboxContainer checkboxContainer-withDescription">
            <label class="emby-checkbox-label">
              <input id="IncludeUnknownLanguage" type="checkbox" is="emby-checkbox" checked />
              <span>Inclure les images sans langue definie</span>
            </label>
            <div class="fieldDescription">Inclut les affiches dont la langue n'est pas specifiee par le provider</div>
          </div>

          <!-- BOUTON SAVE -->
          <div style="margin-top: 30px;">
            <button is="emby-button" type="submit" class="raised button-submit block emby-button">
              <span>Enregistrer</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <script type="text/javascript">
      (function () {
        var pluginId = '7f6eea8b-0e9c-4cbd-9d2a-31f9a37ce2b7';

        function byId(id) { return document.getElementById(id); }

        function createLibraryCheckbox(rule) {
          var div = document.createElement('div');
          div.className = 'checkboxContainer checkboxContainer-withDescription';
          div.style.marginBottom = '8px';

          var label = document.createElement('label');
          label.className = 'emby-checkbox-label';

          var checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.setAttribute('is', 'emby-checkbox');
          checkbox.checked = !!(rule && rule.Enabled);
          checkbox.dataset.libraryName = (rule && rule.Name) ? rule.Name : '';

          var span = document.createElement('span');
          span.textContent = (rule && rule.Name) ? rule.Name : '(sans nom)';

          label.appendChild(checkbox);
          label.appendChild(span);
          div.appendChild(label);

          return div;
        }

        function addLibraryCheckboxToContainer(name, checked) {
          var rule = { Name: name, Enabled: !!checked };
          return createLibraryCheckbox(rule);
        }

        function load() {
          Dashboard.showLoadingMsg();
          ApiClient.getPluginConfiguration(pluginId)
            .then(function (cfg) {
              cfg = cfg || {};
              if (byId('PoolSize')) byId('PoolSize').value = (cfg.PoolSize ?? 5);
              if (byId('MinHoursBetweenSwitches')) byId('MinHoursBetweenSwitches').value = (cfg.MinHoursBetweenSwitches ?? 24);
              if (byId('SequentialRotation')) byId('SequentialRotation').checked = !!cfg.SequentialRotation;
              if (byId('LockImagesAfterFill')) byId('LockImagesAfterFill').checked = !!cfg.LockImagesAfterFill;
              if (byId('TriggerLibraryScanAfterRotation')) byId('TriggerLibraryScanAfterRotation').checked = (cfg.TriggerLibraryScanAfterRotation === undefined ? true : !!cfg.TriggerLibraryScanAfterRotation);

              if (byId('EnableSeasonPosters')) byId('EnableSeasonPosters').checked = !!cfg.EnableSeasonPosters;
              if (byId('EnableEpisodePosters')) byId('EnableEpisodePosters').checked = !!cfg.EnableEpisodePosters;

              // Pool management options
              if (byId('AutoCleanupOrphanedPools')) byId('AutoCleanupOrphanedPools').checked = !!cfg.AutoCleanupOrphanedPools;
              if (byId('CleanupIntervalDays')) byId('CleanupIntervalDays').value = (cfg.CleanupIntervalDays ?? 7);

              // Image quality
              if (byId('MinImageWidth')) byId('MinImageWidth').value = (cfg.MinImageWidth ?? 500);
              if (byId('MinImageHeight')) byId('MinImageHeight').value = (cfg.MinImageHeight ?? 750);
              if (byId('EnableDuplicateDetection')) byId('EnableDuplicateDetection').checked = !!cfg.EnableDuplicateDetection;

              // Language preferences
              if (byId('EnableLanguageFilter')) byId('EnableLanguageFilter').checked = !!cfg.EnableLanguageFilter;
              if (byId('PreferredLanguage')) byId('PreferredLanguage').value = (cfg.PreferredLanguage ?? 'fr');
              if (byId('MaxPreferredLanguageImages')) byId('MaxPreferredLanguageImages').value = (cfg.MaxPreferredLanguageImages ?? 2);
              if (byId('UseOriginalLanguageAsFallback')) byId('UseOriginalLanguageAsFallback').checked = (cfg.UseOriginalLanguageAsFallback === undefined ? true : !!cfg.UseOriginalLanguageAsFallback);
              if (byId('FallbackLanguage')) byId('FallbackLanguage').value = (cfg.FallbackLanguage ?? 'en');
              if (byId('IncludeUnknownLanguage')) byId('IncludeUnknownLanguage').checked = (cfg.IncludeUnknownLanguage === undefined ? true : !!cfg.IncludeUnknownLanguage);

              // ExtraPosterPatterns may be stored as an array; guard accordingly
              try {
                var extraArr = Array.isArray(cfg.ExtraPosterPatterns) ? cfg.ExtraPosterPatterns : (cfg.ExtraPosterPatterns ? cfg.ExtraPosterPatterns : []);
                if (byId('ExtraPosterPatterns')) byId('ExtraPosterPatterns').value = (extraArr || []).join(', ');
              } catch (e) {
                if (byId('ExtraPosterPatterns')) byId('ExtraPosterPatterns').value = '';
              }

              // Load libraries from saved configuration: show LibraryRules and manual roots
              console.log('PosterRotator: saved LibraryRules from server:', cfg.LibraryRules);
              var container = byId('LibraryRulesContainer');
              if (container) {
                container.innerHTML = '';
                var existing = (cfg.LibraryRules || []);
                if (existing.length > 0) {
                  existing.forEach(function (rule) {
                    container.appendChild(addLibraryCheckboxToContainer(rule.Name, !!rule.Enabled));
                  });
                }
              }
              // --- auto-fill LibraryRules from server if none saved (improved with debug) ---
              (function fillLibrariesIfEmpty() {
                var container = byId('LibraryRulesContainer');
                if (!container) {
                  console.warn('PosterRotator: #LibraryRulesContainer introuvable dans le DOM.');
                  return;
                }

                var existing = (cfg.LibraryRules || []);
                if (existing.length > 0) {
                  console.log('PosterRotator: LibraryRules d√©j√† pr√©sentes dans cfg, on ne remplace pas.');
                  return; // on garde ce qui est sauvegard√©
                }

                console.log('PosterRotator: tentative de r√©cup√©ration des VirtualFolders du serveur...');

                function getVirtualFolders() {
                  if (typeof ApiClient !== 'undefined' && ApiClient.get) {
                    // üîß Correction : on lit le JSON de la r√©ponse
                    return ApiClient.get('/Library/VirtualFolders').then(r => r.json());
                  }
                  // fallback direct
                  return fetch('/Library/VirtualFolders', { credentials: 'same-origin' })
                    .then(function (r) {
                      if (!r.ok) throw new Error('HTTP ' + r.status);
                      return r.json();
                    });
                }

                getVirtualFolders()
                  .then(function (res) {
                    console.log('PosterRotator: r√©ponse VirtualFolders re√ßue :', res);
                    var folders = Array.isArray(res) ? res : (res.Items || []);
                    if (!folders || folders.length === 0) {
                      container.innerHTML = '<div class="fieldDescription">Aucune biblioth√®que d√©tect√©e. (r√©ponse vide)</div>';
                      return;
                    }

                    container.innerHTML = '';
                    folders.forEach(function (f) {
                      var name = f.Name || f.DisplayName || (f.Path ? f.Path.split(/[\\/]/).pop() : 'Unknown');
                      container.appendChild(addLibraryCheckboxToContainer(name, true));
                    });

                    console.log('PosterRotator: biblioth√®ques ajout√©es au DOM:', folders.map(function (f) { return f.Name || f.DisplayName; }));
                  })
                  .catch(function (err) {
                    console.error('PosterRotator: erreur chargement biblioth√®ques:', err);
                    // Afficher plus de d√©tails si possible
                    if (err && err.status) {
                      container.innerHTML = '<div class="fieldDescription" style="color:#c00">Impossible de charger les biblioth√®ques (HTTP ' + err.status + ')</div>';
                    } else {
                      container.innerHTML = '<div class="fieldDescription" style="color:#c00">Impossible de charger les biblioth√®ques (voir console pour d√©tails)</div>';
                    }
                  });
              })();

              // Fill manual roots textarea
              try {
                var rootsText = '';
                if (Array.isArray(cfg.ManualLibraryRoots)) rootsText = cfg.ManualLibraryRoots.join('\n');
                if (byId('ManualLibraryRoots')) byId('ManualLibraryRoots').value = rootsText;
              } catch (e) { console.error(e); }
            })
            .catch(function (err) {
              console.error('PosterRotator load error:', err);
              alert('Erreur lors du chargement de la configuration. Voir la console.');
            })
            .finally(function () { Dashboard.hideLoadingMsg(); });
        }

        function save(e) {
          e && e.preventDefault();
          Dashboard.showLoadingMsg();

          ApiClient.getPluginConfiguration(pluginId)
            .then(function (cfg) {
              cfg = cfg || {};

              // Lecture et validation du PoolSize
              var rawValue = byId('PoolSize')?.value;
              console.log('[PosterRotator] PoolSize input value:', rawValue);

              var n = parseInt(rawValue, 10);

              if (isNaN(n) || n < 1) {
                alert("Valeur de PoolSize invalide. Entrez un nombre sup√©rieur ou √©gal √† 1.");
                Dashboard.hideLoadingMsg();
                return; // stop la sauvegarde
              }

              cfg.PoolSize = n;

              // V√©rification avant envoi
              console.log('[PosterRotator] PoolSize enregistr√© dans cfg:', cfg.PoolSize);


              var h = parseInt((byId('MinHoursBetweenSwitches')?.value || '24'), 10);
              cfg.MinHoursBetweenSwitches = (isNaN(h) || h < 1) ? 24 : h;

              // Booleans
              cfg.SequentialRotation = !!(byId('SequentialRotation') && byId('SequentialRotation').checked);
              cfg.LockImagesAfterFill = !!(byId('LockImagesAfterFill') && byId('LockImagesAfterFill').checked);
              cfg.TriggerLibraryScanAfterRotation = !!(byId('TriggerLibraryScanAfterRotation') && byId('TriggerLibraryScanAfterRotation').checked);
              cfg.EnableSeasonPosters = !!(byId('EnableSeasonPosters') && byId('EnableSeasonPosters').checked);
              cfg.EnableEpisodePosters = !!(byId('EnableEpisodePosters') && byId('EnableEpisodePosters').checked);

              // Pool management options
              cfg.AutoCleanupOrphanedPools = !!(byId('AutoCleanupOrphanedPools') && byId('AutoCleanupOrphanedPools').checked);
              var cleanupDays = parseInt((byId('CleanupIntervalDays')?.value || '7'), 10);
              cfg.CleanupIntervalDays = (isNaN(cleanupDays) || cleanupDays < 1) ? 7 : cleanupDays;

              // Image quality
              var minW = parseInt((byId('MinImageWidth')?.value || '500'), 10);
              cfg.MinImageWidth = (isNaN(minW) || minW < 0) ? 500 : minW;
              var minH = parseInt((byId('MinImageHeight')?.value || '750'), 10);
              cfg.MinImageHeight = (isNaN(minH) || minH < 0) ? 750 : minH;
              cfg.EnableDuplicateDetection = !!(byId('EnableDuplicateDetection') && byId('EnableDuplicateDetection').checked);

              // Language preferences
              cfg.EnableLanguageFilter = !!(byId('EnableLanguageFilter') && byId('EnableLanguageFilter').checked);
              cfg.PreferredLanguage = (byId('PreferredLanguage')?.value || 'fr').trim();
              var maxPrefLang = parseInt((byId('MaxPreferredLanguageImages')?.value || '2'), 10);
              cfg.MaxPreferredLanguageImages = (isNaN(maxPrefLang) || maxPrefLang < 0) ? 2 : maxPrefLang;
              cfg.UseOriginalLanguageAsFallback = !!(byId('UseOriginalLanguageAsFallback') && byId('UseOriginalLanguageAsFallback').checked);
              cfg.FallbackLanguage = (byId('FallbackLanguage')?.value || '').trim();
              cfg.IncludeUnknownLanguage = !!(byId('IncludeUnknownLanguage') && byId('IncludeUnknownLanguage').checked);

              // Patterns
              var extra = (byId('ExtraPosterPatterns')?.value || '');
              cfg.ExtraPosterPatterns = extra.split(',').map(function (s) { return s.trim(); }).filter(Boolean);

              // Libraries (saved rules)
              var libraryCheckboxes = document.querySelectorAll('#LibraryRulesContainer input[type="checkbox"]');
              cfg.LibraryRules = [];
              libraryCheckboxes.forEach(function (cb) {
                var name = cb.dataset.libraryName || (cb.parentElement ? (cb.parentElement.querySelector('span')?.textContent) : null) || 'Unknown';
                cfg.LibraryRules.push({
                  Name: name,
                  Enabled: !!cb.checked
                });
              });

              // Manual library roots (one per line)
              try {
                var rootsVal = (byId('ManualLibraryRoots')?.value || '').split(/\r?\n/).map(function (s) { return s.trim(); }).filter(Boolean);
                cfg.ManualLibraryRoots = rootsVal;
              } catch (e) { cfg.ManualLibraryRoots = []; }

              console.log('[PosterRotator] Configuration envoy√©e au serveur:', JSON.stringify(cfg, null, 2));
              return ApiClient.updatePluginConfiguration(pluginId, cfg);
            })
            .then(function (result) { Dashboard.processPluginConfigurationUpdateResult(result); })
            .catch(function (err) {
              console.error('PosterRotator save error:', err);
              alert('Erreur lors de la sauvegarde. Voir la console.');
            })
            .finally(function () { Dashboard.hideLoadingMsg(); });

          return false;
        }

        var root = byId('PosterRotatorConfigPage');
        var form = byId('PosterRotatorConfigForm');

        if (root) {
          root.addEventListener('pageshow', load);
          root.addEventListener('viewshow', load);
        }
        if (form) {
          form.addEventListener('submit', save);
        }

        // Purge button handler
        var purgeBtn = byId('PurgeAllPoolsBtn');
        if (purgeBtn) {
          purgeBtn.addEventListener('click', function () {
            if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr ? Cela supprimera TOUS les dossiers .poster_pool de toutes vos biblioth√®ques. Cette action est irr√©versible.')) return;
            purgeBtn.disabled = true;
            purgeBtn.textContent = '‚è≥ Suppression en cours...';
            var resultDiv = byId('PurgeResult');
            ApiClient.ajax({
              type: 'POST',
              url: ApiClient.getUrl('PosterRotator/PurgeAllPools'),
              dataType: 'json'
            }).then(function (data) {
              purgeBtn.disabled = false;
              purgeBtn.textContent = 'üóë Supprimer tous les pools';
              if (resultDiv) {
                resultDiv.style.display = 'block';
                resultDiv.textContent = '‚úÖ ' + (data.DeletedCount || 0) + ' pool(s) supprim√©(s).';
                setTimeout(function () { resultDiv.style.display = 'none'; }, 5000);
              }
            }).catch(function (err) {
              purgeBtn.disabled = false;
              purgeBtn.textContent = 'üóë Supprimer tous les pools';
              console.error('PosterRotator purge error:', err);
              alert('Erreur lors de la suppression. Voir la console.');
            });
          });
        }
      })();
    </script>
  </div>
</body>

</html>